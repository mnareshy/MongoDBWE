INSERT

> db.movies.insertOne({"title":"bahubali","year":"2014","imdb":"2014bb"})
> db.movies.insertOne({"title":"bahubali","year":"2014","_id":"2014bb"})

> db.movies.insertMany([
	 {"title":"bahubali","year":"2014","_id":"2014bb1"},
	 {"title":"bahubali2","year":"2017","_id":"2017bb"},
	 {"title":"bale bale magadivoi","year":"2015","_id":"2015bbmv"},
	 {"title":"premam","year":"2016","_id":"2016pm"} ])
	 
> db.movies.insertMany([
	 {"title":"bahubali","year":"2014","_id":"2014bb1"},
	 {"title":"bahubali2","year":"2017","_id":"2017bb"},
	 {"title":"bale bale magadivoi","year":"2015","_id":"2015bbmv"},
	 {"title":"premam","year":"2016","_id":"2016pm"},
	 {"title":"premam","year":"2016","_id":"2016pm1"}],
	 {"ordered":false});
	 
// by default inserMany is ordered , which means that if there is an error in one of the document
//it wont insert the remaining documents.
//if the "ordered":false , it will still continue to insert other records! 

// Mongo Db creates the Object ID if we dongt supply , and the format as follows
// Date-MAC Address-PID-counter    its a 12 digit hex string(4-3-2-3 bytes respectively)	 
	 
DELETE

>db.movies.drop()

SEARCH - READINg DOCUMENTS

>db.movies.find()
>db.movies.find().pretty()

// pretty() helps for formatting

>db.movies.find({"year":"2016"})
>db.movies.find({"title":"premam","year":"2016"})

>db.movies.find().count();

>db.movies.find({"rating.score":70}) // "" necessary when using nested document fields

>db.movies.find({"actors":["chiranjeevi","balakrishna","ramyakrishna","sudha"]})  
// only finds if all the array elements matches
//And only if the order also matches

>db.movies.find({"actors":"chiranjeevi"})
//to search one element matches

>db.movies.find({"actors":"chiranjeevi","actors":"balakrishna"})
//to search multiple elements matches 


>db.movies.find({"actors.0":"chiranjeevi"})
//to search one element matches that too in a specific location

// find command gives the result in batch, maximum batch size not exceeding 1 mb
//to iterate further use "it" command

CURSORS

>var c =  db.movies.find();
>var doc = function(){return c.hasNext()?c.next():null;}
>c.objsLeftInBatch();

PROJECTIONS

>db.movies.find({"title":"movie1"},{"title":1}) 
//this is explicitly including , _id comes by default
>db.movies.find({"title":"movie1"},{"title":1,"_id":0})
//this excludes _id , inclusions and exclusions in combinations works only with _id field
>db.movies.find({"title":"movie1"},{"actors":0,"_id":0})
//this is explicitly excluding some fields

OPERATORS

>db.movies.find({"rating.rank":{$gte:2, $lte:12}},{"title":1,"rating":1,"_id":0}).pretty()
>db.movies.find({"rating.rank":{$gte:2}, "rating.score":{$lte:91}},{"title":1,"rating":1,"_id":0}).pretty()

>db.movies.find({"rating.score":{$ne:0}},{"title":1,"rating":1,"_id":0}).pretty()
//this will not only gives the documents that have score 0, but also the documents those doesn't contain rating.score field as well!


>db.movies.find({"rating.score":{$in:[90,91,97,99]}},{"title":1,"rating":1,"_id":0}).pretty()
//$in should be always in a array


ELEMENT OPERATORS

>db.movies.find({"rating":{$exists:true}},{"title":1,"rating":1,"_id":0}).pretty()
>db.movies.find({"rating.score":{$exists:true}},{"title":1,"rating":1,"_id":0}).pretty()
>db.movies.find({"rating":{$exists:false}},{"title":1,"rating":1,"_id":0}).pretty()
>db.movies.find({"actors":{$exists:true}},{"title":1,"actors":1,"_id":0}).pretty()


>db.movies.find({"_id":{$type:"string"}},{"title":1,"rating":1,"_id":0}).pretty()
>db.movies.find({"_id":{$type:"string"}},{"title":1,"actors":1,"_id":0}).pretty()


LOGICAL OPERATORS

>db.movies.find({"$or":[{"rating":{$exists:true}},{"actors":{$exists:true}}]},{"title":1,"rating":1,"actors":1,"_id":0}).pretty()
// $or operator always takes an array

>db.movies.find({"$and":[{"rating":{$exists:true}},{"actors":{$exists:true}}]},{"title":1,"rating":1,"actors":1,"_id":0}).pretty()
// $and operator always takes an array
>db.movies.find({"rating":{$exists:true},"actors":{$exists:true}},{"title":1,"rating":1,"actors":1,"_id":0}).pretty()
//This gives the same result as $and operator , but if there is a need on anding results on same element this command gives improper results.
//$and is appropriate in that scenario
>db.movies.find({"$and":[{"rating.score":{$exists:true}},{"rating.score":{$gte:91}}]},{"title":1,"rating":1,"actors":1,"_id":0}).pretty()



















